// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: object_detection/protos/optimizer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_object_5fdetection_2fprotos_2foptimizer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_object_5fdetection_2fprotos_2foptimizer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_object_5fdetection_2fprotos_2foptimizer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_object_5fdetection_2fprotos_2foptimizer_2eproto;
namespace object_detection {
namespace protos {
class AdamOptimizer;
struct AdamOptimizerDefaultTypeInternal;
extern AdamOptimizerDefaultTypeInternal _AdamOptimizer_default_instance_;
class ConstantLearningRate;
struct ConstantLearningRateDefaultTypeInternal;
extern ConstantLearningRateDefaultTypeInternal _ConstantLearningRate_default_instance_;
class CosineDecayLearningRate;
struct CosineDecayLearningRateDefaultTypeInternal;
extern CosineDecayLearningRateDefaultTypeInternal _CosineDecayLearningRate_default_instance_;
class ExponentialDecayLearningRate;
struct ExponentialDecayLearningRateDefaultTypeInternal;
extern ExponentialDecayLearningRateDefaultTypeInternal _ExponentialDecayLearningRate_default_instance_;
class LearningRate;
struct LearningRateDefaultTypeInternal;
extern LearningRateDefaultTypeInternal _LearningRate_default_instance_;
class ManualStepLearningRate;
struct ManualStepLearningRateDefaultTypeInternal;
extern ManualStepLearningRateDefaultTypeInternal _ManualStepLearningRate_default_instance_;
class ManualStepLearningRate_LearningRateSchedule;
struct ManualStepLearningRate_LearningRateScheduleDefaultTypeInternal;
extern ManualStepLearningRate_LearningRateScheduleDefaultTypeInternal _ManualStepLearningRate_LearningRateSchedule_default_instance_;
class MomentumOptimizer;
struct MomentumOptimizerDefaultTypeInternal;
extern MomentumOptimizerDefaultTypeInternal _MomentumOptimizer_default_instance_;
class Optimizer;
struct OptimizerDefaultTypeInternal;
extern OptimizerDefaultTypeInternal _Optimizer_default_instance_;
class RMSPropOptimizer;
struct RMSPropOptimizerDefaultTypeInternal;
extern RMSPropOptimizerDefaultTypeInternal _RMSPropOptimizer_default_instance_;
}  // namespace protos
}  // namespace object_detection
PROTOBUF_NAMESPACE_OPEN
template<> ::object_detection::protos::AdamOptimizer* Arena::CreateMaybeMessage<::object_detection::protos::AdamOptimizer>(Arena*);
template<> ::object_detection::protos::ConstantLearningRate* Arena::CreateMaybeMessage<::object_detection::protos::ConstantLearningRate>(Arena*);
template<> ::object_detection::protos::CosineDecayLearningRate* Arena::CreateMaybeMessage<::object_detection::protos::CosineDecayLearningRate>(Arena*);
template<> ::object_detection::protos::ExponentialDecayLearningRate* Arena::CreateMaybeMessage<::object_detection::protos::ExponentialDecayLearningRate>(Arena*);
template<> ::object_detection::protos::LearningRate* Arena::CreateMaybeMessage<::object_detection::protos::LearningRate>(Arena*);
template<> ::object_detection::protos::ManualStepLearningRate* Arena::CreateMaybeMessage<::object_detection::protos::ManualStepLearningRate>(Arena*);
template<> ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* Arena::CreateMaybeMessage<::object_detection::protos::ManualStepLearningRate_LearningRateSchedule>(Arena*);
template<> ::object_detection::protos::MomentumOptimizer* Arena::CreateMaybeMessage<::object_detection::protos::MomentumOptimizer>(Arena*);
template<> ::object_detection::protos::Optimizer* Arena::CreateMaybeMessage<::object_detection::protos::Optimizer>(Arena*);
template<> ::object_detection::protos::RMSPropOptimizer* Arena::CreateMaybeMessage<::object_detection::protos::RMSPropOptimizer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace object_detection {
namespace protos {

// ===================================================================

class Optimizer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.Optimizer) */ {
 public:
  inline Optimizer() : Optimizer(nullptr) {}
  ~Optimizer() override;
  explicit constexpr Optimizer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Optimizer(const Optimizer& from);
  Optimizer(Optimizer&& from) noexcept
    : Optimizer() {
    *this = ::std::move(from);
  }

  inline Optimizer& operator=(const Optimizer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Optimizer& operator=(Optimizer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Optimizer& default_instance() {
    return *internal_default_instance();
  }
  enum OptimizerCase {
    kRmsPropOptimizer = 1,
    kMomentumOptimizer = 2,
    kAdamOptimizer = 3,
    OPTIMIZER_NOT_SET = 0,
  };

  static inline const Optimizer* internal_default_instance() {
    return reinterpret_cast<const Optimizer*>(
               &_Optimizer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Optimizer& a, Optimizer& b) {
    a.Swap(&b);
  }
  inline void Swap(Optimizer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Optimizer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Optimizer* New() const final {
    return new Optimizer();
  }

  Optimizer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Optimizer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Optimizer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Optimizer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Optimizer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.Optimizer";
  }
  protected:
  explicit Optimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseMovingAverageFieldNumber = 4,
    kMovingAverageDecayFieldNumber = 5,
    kRmsPropOptimizerFieldNumber = 1,
    kMomentumOptimizerFieldNumber = 2,
    kAdamOptimizerFieldNumber = 3,
  };
  // optional bool use_moving_average = 4 [default = true];
  bool has_use_moving_average() const;
  private:
  bool _internal_has_use_moving_average() const;
  public:
  void clear_use_moving_average();
  bool use_moving_average() const;
  void set_use_moving_average(bool value);
  private:
  bool _internal_use_moving_average() const;
  void _internal_set_use_moving_average(bool value);
  public:

  // optional float moving_average_decay = 5 [default = 0.9999];
  bool has_moving_average_decay() const;
  private:
  bool _internal_has_moving_average_decay() const;
  public:
  void clear_moving_average_decay();
  float moving_average_decay() const;
  void set_moving_average_decay(float value);
  private:
  float _internal_moving_average_decay() const;
  void _internal_set_moving_average_decay(float value);
  public:

  // .object_detection.protos.RMSPropOptimizer rms_prop_optimizer = 1;
  bool has_rms_prop_optimizer() const;
  private:
  bool _internal_has_rms_prop_optimizer() const;
  public:
  void clear_rms_prop_optimizer();
  const ::object_detection::protos::RMSPropOptimizer& rms_prop_optimizer() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::RMSPropOptimizer* release_rms_prop_optimizer();
  ::object_detection::protos::RMSPropOptimizer* mutable_rms_prop_optimizer();
  void set_allocated_rms_prop_optimizer(::object_detection::protos::RMSPropOptimizer* rms_prop_optimizer);
  private:
  const ::object_detection::protos::RMSPropOptimizer& _internal_rms_prop_optimizer() const;
  ::object_detection::protos::RMSPropOptimizer* _internal_mutable_rms_prop_optimizer();
  public:
  void unsafe_arena_set_allocated_rms_prop_optimizer(
      ::object_detection::protos::RMSPropOptimizer* rms_prop_optimizer);
  ::object_detection::protos::RMSPropOptimizer* unsafe_arena_release_rms_prop_optimizer();

  // .object_detection.protos.MomentumOptimizer momentum_optimizer = 2;
  bool has_momentum_optimizer() const;
  private:
  bool _internal_has_momentum_optimizer() const;
  public:
  void clear_momentum_optimizer();
  const ::object_detection::protos::MomentumOptimizer& momentum_optimizer() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::MomentumOptimizer* release_momentum_optimizer();
  ::object_detection::protos::MomentumOptimizer* mutable_momentum_optimizer();
  void set_allocated_momentum_optimizer(::object_detection::protos::MomentumOptimizer* momentum_optimizer);
  private:
  const ::object_detection::protos::MomentumOptimizer& _internal_momentum_optimizer() const;
  ::object_detection::protos::MomentumOptimizer* _internal_mutable_momentum_optimizer();
  public:
  void unsafe_arena_set_allocated_momentum_optimizer(
      ::object_detection::protos::MomentumOptimizer* momentum_optimizer);
  ::object_detection::protos::MomentumOptimizer* unsafe_arena_release_momentum_optimizer();

  // .object_detection.protos.AdamOptimizer adam_optimizer = 3;
  bool has_adam_optimizer() const;
  private:
  bool _internal_has_adam_optimizer() const;
  public:
  void clear_adam_optimizer();
  const ::object_detection::protos::AdamOptimizer& adam_optimizer() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::AdamOptimizer* release_adam_optimizer();
  ::object_detection::protos::AdamOptimizer* mutable_adam_optimizer();
  void set_allocated_adam_optimizer(::object_detection::protos::AdamOptimizer* adam_optimizer);
  private:
  const ::object_detection::protos::AdamOptimizer& _internal_adam_optimizer() const;
  ::object_detection::protos::AdamOptimizer* _internal_mutable_adam_optimizer();
  public:
  void unsafe_arena_set_allocated_adam_optimizer(
      ::object_detection::protos::AdamOptimizer* adam_optimizer);
  ::object_detection::protos::AdamOptimizer* unsafe_arena_release_adam_optimizer();

  void clear_optimizer();
  OptimizerCase optimizer_case() const;
  // @@protoc_insertion_point(class_scope:object_detection.protos.Optimizer)
 private:
  class _Internal;
  void set_has_rms_prop_optimizer();
  void set_has_momentum_optimizer();
  void set_has_adam_optimizer();

  inline bool has_optimizer() const;
  inline void clear_has_optimizer();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_moving_average_;
  float moving_average_decay_;
  union OptimizerUnion {
    constexpr OptimizerUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::object_detection::protos::RMSPropOptimizer* rms_prop_optimizer_;
    ::object_detection::protos::MomentumOptimizer* momentum_optimizer_;
    ::object_detection::protos::AdamOptimizer* adam_optimizer_;
  } optimizer_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class RMSPropOptimizer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.RMSPropOptimizer) */ {
 public:
  inline RMSPropOptimizer() : RMSPropOptimizer(nullptr) {}
  ~RMSPropOptimizer() override;
  explicit constexpr RMSPropOptimizer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RMSPropOptimizer(const RMSPropOptimizer& from);
  RMSPropOptimizer(RMSPropOptimizer&& from) noexcept
    : RMSPropOptimizer() {
    *this = ::std::move(from);
  }

  inline RMSPropOptimizer& operator=(const RMSPropOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RMSPropOptimizer& operator=(RMSPropOptimizer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RMSPropOptimizer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RMSPropOptimizer* internal_default_instance() {
    return reinterpret_cast<const RMSPropOptimizer*>(
               &_RMSPropOptimizer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RMSPropOptimizer& a, RMSPropOptimizer& b) {
    a.Swap(&b);
  }
  inline void Swap(RMSPropOptimizer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RMSPropOptimizer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RMSPropOptimizer* New() const final {
    return new RMSPropOptimizer();
  }

  RMSPropOptimizer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RMSPropOptimizer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RMSPropOptimizer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RMSPropOptimizer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RMSPropOptimizer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.RMSPropOptimizer";
  }
  protected:
  explicit RMSPropOptimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLearningRateFieldNumber = 1,
    kEpsilonFieldNumber = 4,
    kMomentumOptimizerValueFieldNumber = 2,
    kDecayFieldNumber = 3,
  };
  // optional .object_detection.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  private:
  bool _internal_has_learning_rate() const;
  public:
  void clear_learning_rate();
  const ::object_detection::protos::LearningRate& learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::LearningRate* release_learning_rate();
  ::object_detection::protos::LearningRate* mutable_learning_rate();
  void set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate);
  private:
  const ::object_detection::protos::LearningRate& _internal_learning_rate() const;
  ::object_detection::protos::LearningRate* _internal_mutable_learning_rate();
  public:
  void unsafe_arena_set_allocated_learning_rate(
      ::object_detection::protos::LearningRate* learning_rate);
  ::object_detection::protos::LearningRate* unsafe_arena_release_learning_rate();

  // optional float epsilon = 4 [default = 1];
  bool has_epsilon() const;
  private:
  bool _internal_has_epsilon() const;
  public:
  void clear_epsilon();
  float epsilon() const;
  void set_epsilon(float value);
  private:
  float _internal_epsilon() const;
  void _internal_set_epsilon(float value);
  public:

  // optional float momentum_optimizer_value = 2 [default = 0.9];
  bool has_momentum_optimizer_value() const;
  private:
  bool _internal_has_momentum_optimizer_value() const;
  public:
  void clear_momentum_optimizer_value();
  float momentum_optimizer_value() const;
  void set_momentum_optimizer_value(float value);
  private:
  float _internal_momentum_optimizer_value() const;
  void _internal_set_momentum_optimizer_value(float value);
  public:

  // optional float decay = 3 [default = 0.9];
  bool has_decay() const;
  private:
  bool _internal_has_decay() const;
  public:
  void clear_decay();
  float decay() const;
  void set_decay(float value);
  private:
  float _internal_decay() const;
  void _internal_set_decay(float value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.RMSPropOptimizer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::object_detection::protos::LearningRate* learning_rate_;
  float epsilon_;
  float momentum_optimizer_value_;
  float decay_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class MomentumOptimizer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.MomentumOptimizer) */ {
 public:
  inline MomentumOptimizer() : MomentumOptimizer(nullptr) {}
  ~MomentumOptimizer() override;
  explicit constexpr MomentumOptimizer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MomentumOptimizer(const MomentumOptimizer& from);
  MomentumOptimizer(MomentumOptimizer&& from) noexcept
    : MomentumOptimizer() {
    *this = ::std::move(from);
  }

  inline MomentumOptimizer& operator=(const MomentumOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MomentumOptimizer& operator=(MomentumOptimizer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MomentumOptimizer& default_instance() {
    return *internal_default_instance();
  }
  static inline const MomentumOptimizer* internal_default_instance() {
    return reinterpret_cast<const MomentumOptimizer*>(
               &_MomentumOptimizer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MomentumOptimizer& a, MomentumOptimizer& b) {
    a.Swap(&b);
  }
  inline void Swap(MomentumOptimizer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MomentumOptimizer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MomentumOptimizer* New() const final {
    return new MomentumOptimizer();
  }

  MomentumOptimizer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MomentumOptimizer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MomentumOptimizer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MomentumOptimizer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MomentumOptimizer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.MomentumOptimizer";
  }
  protected:
  explicit MomentumOptimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLearningRateFieldNumber = 1,
    kMomentumOptimizerValueFieldNumber = 2,
  };
  // optional .object_detection.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  private:
  bool _internal_has_learning_rate() const;
  public:
  void clear_learning_rate();
  const ::object_detection::protos::LearningRate& learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::LearningRate* release_learning_rate();
  ::object_detection::protos::LearningRate* mutable_learning_rate();
  void set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate);
  private:
  const ::object_detection::protos::LearningRate& _internal_learning_rate() const;
  ::object_detection::protos::LearningRate* _internal_mutable_learning_rate();
  public:
  void unsafe_arena_set_allocated_learning_rate(
      ::object_detection::protos::LearningRate* learning_rate);
  ::object_detection::protos::LearningRate* unsafe_arena_release_learning_rate();

  // optional float momentum_optimizer_value = 2 [default = 0.9];
  bool has_momentum_optimizer_value() const;
  private:
  bool _internal_has_momentum_optimizer_value() const;
  public:
  void clear_momentum_optimizer_value();
  float momentum_optimizer_value() const;
  void set_momentum_optimizer_value(float value);
  private:
  float _internal_momentum_optimizer_value() const;
  void _internal_set_momentum_optimizer_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.MomentumOptimizer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::object_detection::protos::LearningRate* learning_rate_;
  float momentum_optimizer_value_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class AdamOptimizer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.AdamOptimizer) */ {
 public:
  inline AdamOptimizer() : AdamOptimizer(nullptr) {}
  ~AdamOptimizer() override;
  explicit constexpr AdamOptimizer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdamOptimizer(const AdamOptimizer& from);
  AdamOptimizer(AdamOptimizer&& from) noexcept
    : AdamOptimizer() {
    *this = ::std::move(from);
  }

  inline AdamOptimizer& operator=(const AdamOptimizer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdamOptimizer& operator=(AdamOptimizer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdamOptimizer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdamOptimizer* internal_default_instance() {
    return reinterpret_cast<const AdamOptimizer*>(
               &_AdamOptimizer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AdamOptimizer& a, AdamOptimizer& b) {
    a.Swap(&b);
  }
  inline void Swap(AdamOptimizer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdamOptimizer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdamOptimizer* New() const final {
    return new AdamOptimizer();
  }

  AdamOptimizer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdamOptimizer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdamOptimizer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdamOptimizer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdamOptimizer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.AdamOptimizer";
  }
  protected:
  explicit AdamOptimizer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLearningRateFieldNumber = 1,
  };
  // optional .object_detection.protos.LearningRate learning_rate = 1;
  bool has_learning_rate() const;
  private:
  bool _internal_has_learning_rate() const;
  public:
  void clear_learning_rate();
  const ::object_detection::protos::LearningRate& learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::LearningRate* release_learning_rate();
  ::object_detection::protos::LearningRate* mutable_learning_rate();
  void set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate);
  private:
  const ::object_detection::protos::LearningRate& _internal_learning_rate() const;
  ::object_detection::protos::LearningRate* _internal_mutable_learning_rate();
  public:
  void unsafe_arena_set_allocated_learning_rate(
      ::object_detection::protos::LearningRate* learning_rate);
  ::object_detection::protos::LearningRate* unsafe_arena_release_learning_rate();

  // @@protoc_insertion_point(class_scope:object_detection.protos.AdamOptimizer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::object_detection::protos::LearningRate* learning_rate_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class LearningRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.LearningRate) */ {
 public:
  inline LearningRate() : LearningRate(nullptr) {}
  ~LearningRate() override;
  explicit constexpr LearningRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LearningRate(const LearningRate& from);
  LearningRate(LearningRate&& from) noexcept
    : LearningRate() {
    *this = ::std::move(from);
  }

  inline LearningRate& operator=(const LearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline LearningRate& operator=(LearningRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LearningRate& default_instance() {
    return *internal_default_instance();
  }
  enum LearningRateCase {
    kConstantLearningRate = 1,
    kExponentialDecayLearningRate = 2,
    kManualStepLearningRate = 3,
    kCosineDecayLearningRate = 4,
    LEARNING_RATE_NOT_SET = 0,
  };

  static inline const LearningRate* internal_default_instance() {
    return reinterpret_cast<const LearningRate*>(
               &_LearningRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LearningRate& a, LearningRate& b) {
    a.Swap(&b);
  }
  inline void Swap(LearningRate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LearningRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LearningRate* New() const final {
    return new LearningRate();
  }

  LearningRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LearningRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LearningRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LearningRate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearningRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.LearningRate";
  }
  protected:
  explicit LearningRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstantLearningRateFieldNumber = 1,
    kExponentialDecayLearningRateFieldNumber = 2,
    kManualStepLearningRateFieldNumber = 3,
    kCosineDecayLearningRateFieldNumber = 4,
  };
  // .object_detection.protos.ConstantLearningRate constant_learning_rate = 1;
  bool has_constant_learning_rate() const;
  private:
  bool _internal_has_constant_learning_rate() const;
  public:
  void clear_constant_learning_rate();
  const ::object_detection::protos::ConstantLearningRate& constant_learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::ConstantLearningRate* release_constant_learning_rate();
  ::object_detection::protos::ConstantLearningRate* mutable_constant_learning_rate();
  void set_allocated_constant_learning_rate(::object_detection::protos::ConstantLearningRate* constant_learning_rate);
  private:
  const ::object_detection::protos::ConstantLearningRate& _internal_constant_learning_rate() const;
  ::object_detection::protos::ConstantLearningRate* _internal_mutable_constant_learning_rate();
  public:
  void unsafe_arena_set_allocated_constant_learning_rate(
      ::object_detection::protos::ConstantLearningRate* constant_learning_rate);
  ::object_detection::protos::ConstantLearningRate* unsafe_arena_release_constant_learning_rate();

  // .object_detection.protos.ExponentialDecayLearningRate exponential_decay_learning_rate = 2;
  bool has_exponential_decay_learning_rate() const;
  private:
  bool _internal_has_exponential_decay_learning_rate() const;
  public:
  void clear_exponential_decay_learning_rate();
  const ::object_detection::protos::ExponentialDecayLearningRate& exponential_decay_learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::ExponentialDecayLearningRate* release_exponential_decay_learning_rate();
  ::object_detection::protos::ExponentialDecayLearningRate* mutable_exponential_decay_learning_rate();
  void set_allocated_exponential_decay_learning_rate(::object_detection::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate);
  private:
  const ::object_detection::protos::ExponentialDecayLearningRate& _internal_exponential_decay_learning_rate() const;
  ::object_detection::protos::ExponentialDecayLearningRate* _internal_mutable_exponential_decay_learning_rate();
  public:
  void unsafe_arena_set_allocated_exponential_decay_learning_rate(
      ::object_detection::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate);
  ::object_detection::protos::ExponentialDecayLearningRate* unsafe_arena_release_exponential_decay_learning_rate();

  // .object_detection.protos.ManualStepLearningRate manual_step_learning_rate = 3;
  bool has_manual_step_learning_rate() const;
  private:
  bool _internal_has_manual_step_learning_rate() const;
  public:
  void clear_manual_step_learning_rate();
  const ::object_detection::protos::ManualStepLearningRate& manual_step_learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::ManualStepLearningRate* release_manual_step_learning_rate();
  ::object_detection::protos::ManualStepLearningRate* mutable_manual_step_learning_rate();
  void set_allocated_manual_step_learning_rate(::object_detection::protos::ManualStepLearningRate* manual_step_learning_rate);
  private:
  const ::object_detection::protos::ManualStepLearningRate& _internal_manual_step_learning_rate() const;
  ::object_detection::protos::ManualStepLearningRate* _internal_mutable_manual_step_learning_rate();
  public:
  void unsafe_arena_set_allocated_manual_step_learning_rate(
      ::object_detection::protos::ManualStepLearningRate* manual_step_learning_rate);
  ::object_detection::protos::ManualStepLearningRate* unsafe_arena_release_manual_step_learning_rate();

  // .object_detection.protos.CosineDecayLearningRate cosine_decay_learning_rate = 4;
  bool has_cosine_decay_learning_rate() const;
  private:
  bool _internal_has_cosine_decay_learning_rate() const;
  public:
  void clear_cosine_decay_learning_rate();
  const ::object_detection::protos::CosineDecayLearningRate& cosine_decay_learning_rate() const;
  PROTOBUF_MUST_USE_RESULT ::object_detection::protos::CosineDecayLearningRate* release_cosine_decay_learning_rate();
  ::object_detection::protos::CosineDecayLearningRate* mutable_cosine_decay_learning_rate();
  void set_allocated_cosine_decay_learning_rate(::object_detection::protos::CosineDecayLearningRate* cosine_decay_learning_rate);
  private:
  const ::object_detection::protos::CosineDecayLearningRate& _internal_cosine_decay_learning_rate() const;
  ::object_detection::protos::CosineDecayLearningRate* _internal_mutable_cosine_decay_learning_rate();
  public:
  void unsafe_arena_set_allocated_cosine_decay_learning_rate(
      ::object_detection::protos::CosineDecayLearningRate* cosine_decay_learning_rate);
  ::object_detection::protos::CosineDecayLearningRate* unsafe_arena_release_cosine_decay_learning_rate();

  void clear_learning_rate();
  LearningRateCase learning_rate_case() const;
  // @@protoc_insertion_point(class_scope:object_detection.protos.LearningRate)
 private:
  class _Internal;
  void set_has_constant_learning_rate();
  void set_has_exponential_decay_learning_rate();
  void set_has_manual_step_learning_rate();
  void set_has_cosine_decay_learning_rate();

  inline bool has_learning_rate() const;
  inline void clear_has_learning_rate();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union LearningRateUnion {
    constexpr LearningRateUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::object_detection::protos::ConstantLearningRate* constant_learning_rate_;
    ::object_detection::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate_;
    ::object_detection::protos::ManualStepLearningRate* manual_step_learning_rate_;
    ::object_detection::protos::CosineDecayLearningRate* cosine_decay_learning_rate_;
  } learning_rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class ConstantLearningRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ConstantLearningRate) */ {
 public:
  inline ConstantLearningRate() : ConstantLearningRate(nullptr) {}
  ~ConstantLearningRate() override;
  explicit constexpr ConstantLearningRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstantLearningRate(const ConstantLearningRate& from);
  ConstantLearningRate(ConstantLearningRate&& from) noexcept
    : ConstantLearningRate() {
    *this = ::std::move(from);
  }

  inline ConstantLearningRate& operator=(const ConstantLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantLearningRate& operator=(ConstantLearningRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantLearningRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstantLearningRate* internal_default_instance() {
    return reinterpret_cast<const ConstantLearningRate*>(
               &_ConstantLearningRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConstantLearningRate& a, ConstantLearningRate& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstantLearningRate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantLearningRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConstantLearningRate* New() const final {
    return new ConstantLearningRate();
  }

  ConstantLearningRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConstantLearningRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstantLearningRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConstantLearningRate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstantLearningRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.ConstantLearningRate";
  }
  protected:
  explicit ConstantLearningRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLearningRateFieldNumber = 1,
  };
  // optional float learning_rate = 1 [default = 0.002];
  bool has_learning_rate() const;
  private:
  bool _internal_has_learning_rate() const;
  public:
  void clear_learning_rate();
  float learning_rate() const;
  void set_learning_rate(float value);
  private:
  float _internal_learning_rate() const;
  void _internal_set_learning_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.ConstantLearningRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float learning_rate_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class ExponentialDecayLearningRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ExponentialDecayLearningRate) */ {
 public:
  inline ExponentialDecayLearningRate() : ExponentialDecayLearningRate(nullptr) {}
  ~ExponentialDecayLearningRate() override;
  explicit constexpr ExponentialDecayLearningRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExponentialDecayLearningRate(const ExponentialDecayLearningRate& from);
  ExponentialDecayLearningRate(ExponentialDecayLearningRate&& from) noexcept
    : ExponentialDecayLearningRate() {
    *this = ::std::move(from);
  }

  inline ExponentialDecayLearningRate& operator=(const ExponentialDecayLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExponentialDecayLearningRate& operator=(ExponentialDecayLearningRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExponentialDecayLearningRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExponentialDecayLearningRate* internal_default_instance() {
    return reinterpret_cast<const ExponentialDecayLearningRate*>(
               &_ExponentialDecayLearningRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExponentialDecayLearningRate& a, ExponentialDecayLearningRate& b) {
    a.Swap(&b);
  }
  inline void Swap(ExponentialDecayLearningRate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExponentialDecayLearningRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExponentialDecayLearningRate* New() const final {
    return new ExponentialDecayLearningRate();
  }

  ExponentialDecayLearningRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExponentialDecayLearningRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExponentialDecayLearningRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExponentialDecayLearningRate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExponentialDecayLearningRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.ExponentialDecayLearningRate";
  }
  protected:
  explicit ExponentialDecayLearningRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBurninLearningRateFieldNumber = 5,
    kBurninStepsFieldNumber = 6,
    kMinLearningRateFieldNumber = 7,
    kInitialLearningRateFieldNumber = 1,
    kDecayStepsFieldNumber = 2,
    kDecayFactorFieldNumber = 3,
    kStaircaseFieldNumber = 4,
  };
  // optional float burnin_learning_rate = 5 [default = 0];
  bool has_burnin_learning_rate() const;
  private:
  bool _internal_has_burnin_learning_rate() const;
  public:
  void clear_burnin_learning_rate();
  float burnin_learning_rate() const;
  void set_burnin_learning_rate(float value);
  private:
  float _internal_burnin_learning_rate() const;
  void _internal_set_burnin_learning_rate(float value);
  public:

  // optional uint32 burnin_steps = 6 [default = 0];
  bool has_burnin_steps() const;
  private:
  bool _internal_has_burnin_steps() const;
  public:
  void clear_burnin_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 burnin_steps() const;
  void set_burnin_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_burnin_steps() const;
  void _internal_set_burnin_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float min_learning_rate = 7 [default = 0];
  bool has_min_learning_rate() const;
  private:
  bool _internal_has_min_learning_rate() const;
  public:
  void clear_min_learning_rate();
  float min_learning_rate() const;
  void set_min_learning_rate(float value);
  private:
  float _internal_min_learning_rate() const;
  void _internal_set_min_learning_rate(float value);
  public:

  // optional float initial_learning_rate = 1 [default = 0.002];
  bool has_initial_learning_rate() const;
  private:
  bool _internal_has_initial_learning_rate() const;
  public:
  void clear_initial_learning_rate();
  float initial_learning_rate() const;
  void set_initial_learning_rate(float value);
  private:
  float _internal_initial_learning_rate() const;
  void _internal_set_initial_learning_rate(float value);
  public:

  // optional uint32 decay_steps = 2 [default = 4000000];
  bool has_decay_steps() const;
  private:
  bool _internal_has_decay_steps() const;
  public:
  void clear_decay_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 decay_steps() const;
  void set_decay_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_decay_steps() const;
  void _internal_set_decay_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float decay_factor = 3 [default = 0.95];
  bool has_decay_factor() const;
  private:
  bool _internal_has_decay_factor() const;
  public:
  void clear_decay_factor();
  float decay_factor() const;
  void set_decay_factor(float value);
  private:
  float _internal_decay_factor() const;
  void _internal_set_decay_factor(float value);
  public:

  // optional bool staircase = 4 [default = true];
  bool has_staircase() const;
  private:
  bool _internal_has_staircase() const;
  public:
  void clear_staircase();
  bool staircase() const;
  void set_staircase(bool value);
  private:
  bool _internal_staircase() const;
  void _internal_set_staircase(bool value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.ExponentialDecayLearningRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float burnin_learning_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 burnin_steps_;
  float min_learning_rate_;
  float initial_learning_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 decay_steps_;
  float decay_factor_;
  bool staircase_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class ManualStepLearningRate_LearningRateSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ManualStepLearningRate.LearningRateSchedule) */ {
 public:
  inline ManualStepLearningRate_LearningRateSchedule() : ManualStepLearningRate_LearningRateSchedule(nullptr) {}
  ~ManualStepLearningRate_LearningRateSchedule() override;
  explicit constexpr ManualStepLearningRate_LearningRateSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManualStepLearningRate_LearningRateSchedule(const ManualStepLearningRate_LearningRateSchedule& from);
  ManualStepLearningRate_LearningRateSchedule(ManualStepLearningRate_LearningRateSchedule&& from) noexcept
    : ManualStepLearningRate_LearningRateSchedule() {
    *this = ::std::move(from);
  }

  inline ManualStepLearningRate_LearningRateSchedule& operator=(const ManualStepLearningRate_LearningRateSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManualStepLearningRate_LearningRateSchedule& operator=(ManualStepLearningRate_LearningRateSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManualStepLearningRate_LearningRateSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManualStepLearningRate_LearningRateSchedule* internal_default_instance() {
    return reinterpret_cast<const ManualStepLearningRate_LearningRateSchedule*>(
               &_ManualStepLearningRate_LearningRateSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ManualStepLearningRate_LearningRateSchedule& a, ManualStepLearningRate_LearningRateSchedule& b) {
    a.Swap(&b);
  }
  inline void Swap(ManualStepLearningRate_LearningRateSchedule* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManualStepLearningRate_LearningRateSchedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ManualStepLearningRate_LearningRateSchedule* New() const final {
    return new ManualStepLearningRate_LearningRateSchedule();
  }

  ManualStepLearningRate_LearningRateSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ManualStepLearningRate_LearningRateSchedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManualStepLearningRate_LearningRateSchedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ManualStepLearningRate_LearningRateSchedule& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManualStepLearningRate_LearningRateSchedule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.ManualStepLearningRate.LearningRateSchedule";
  }
  protected:
  explicit ManualStepLearningRate_LearningRateSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStepFieldNumber = 1,
    kLearningRateFieldNumber = 2,
  };
  // optional uint32 step = 1;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  ::PROTOBUF_NAMESPACE_ID::uint32 step() const;
  void set_step(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_step() const;
  void _internal_set_step(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float learning_rate = 2 [default = 0.002];
  bool has_learning_rate() const;
  private:
  bool _internal_has_learning_rate() const;
  public:
  void clear_learning_rate();
  float learning_rate() const;
  void set_learning_rate(float value);
  private:
  float _internal_learning_rate() const;
  void _internal_set_learning_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.ManualStepLearningRate.LearningRateSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 step_;
  float learning_rate_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class ManualStepLearningRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.ManualStepLearningRate) */ {
 public:
  inline ManualStepLearningRate() : ManualStepLearningRate(nullptr) {}
  ~ManualStepLearningRate() override;
  explicit constexpr ManualStepLearningRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManualStepLearningRate(const ManualStepLearningRate& from);
  ManualStepLearningRate(ManualStepLearningRate&& from) noexcept
    : ManualStepLearningRate() {
    *this = ::std::move(from);
  }

  inline ManualStepLearningRate& operator=(const ManualStepLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManualStepLearningRate& operator=(ManualStepLearningRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManualStepLearningRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManualStepLearningRate* internal_default_instance() {
    return reinterpret_cast<const ManualStepLearningRate*>(
               &_ManualStepLearningRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ManualStepLearningRate& a, ManualStepLearningRate& b) {
    a.Swap(&b);
  }
  inline void Swap(ManualStepLearningRate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManualStepLearningRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ManualStepLearningRate* New() const final {
    return new ManualStepLearningRate();
  }

  ManualStepLearningRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ManualStepLearningRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManualStepLearningRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ManualStepLearningRate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManualStepLearningRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.ManualStepLearningRate";
  }
  protected:
  explicit ManualStepLearningRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ManualStepLearningRate_LearningRateSchedule LearningRateSchedule;

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 2,
    kWarmupFieldNumber = 3,
    kInitialLearningRateFieldNumber = 1,
  };
  // repeated .object_detection.protos.ManualStepLearningRate.LearningRateSchedule schedule = 2;
  int schedule_size() const;
  private:
  int _internal_schedule_size() const;
  public:
  void clear_schedule();
  ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* mutable_schedule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule >*
      mutable_schedule();
  private:
  const ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule& _internal_schedule(int index) const;
  ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* _internal_add_schedule();
  public:
  const ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule& schedule(int index) const;
  ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* add_schedule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule >&
      schedule() const;

  // optional bool warmup = 3 [default = false];
  bool has_warmup() const;
  private:
  bool _internal_has_warmup() const;
  public:
  void clear_warmup();
  bool warmup() const;
  void set_warmup(bool value);
  private:
  bool _internal_warmup() const;
  void _internal_set_warmup(bool value);
  public:

  // optional float initial_learning_rate = 1 [default = 0.002];
  bool has_initial_learning_rate() const;
  private:
  bool _internal_has_initial_learning_rate() const;
  public:
  void clear_initial_learning_rate();
  float initial_learning_rate() const;
  void set_initial_learning_rate(float value);
  private:
  float _internal_initial_learning_rate() const;
  void _internal_set_initial_learning_rate(float value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.ManualStepLearningRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule > schedule_;
  bool warmup_;
  float initial_learning_rate_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// -------------------------------------------------------------------

class CosineDecayLearningRate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:object_detection.protos.CosineDecayLearningRate) */ {
 public:
  inline CosineDecayLearningRate() : CosineDecayLearningRate(nullptr) {}
  ~CosineDecayLearningRate() override;
  explicit constexpr CosineDecayLearningRate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CosineDecayLearningRate(const CosineDecayLearningRate& from);
  CosineDecayLearningRate(CosineDecayLearningRate&& from) noexcept
    : CosineDecayLearningRate() {
    *this = ::std::move(from);
  }

  inline CosineDecayLearningRate& operator=(const CosineDecayLearningRate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CosineDecayLearningRate& operator=(CosineDecayLearningRate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CosineDecayLearningRate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CosineDecayLearningRate* internal_default_instance() {
    return reinterpret_cast<const CosineDecayLearningRate*>(
               &_CosineDecayLearningRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CosineDecayLearningRate& a, CosineDecayLearningRate& b) {
    a.Swap(&b);
  }
  inline void Swap(CosineDecayLearningRate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CosineDecayLearningRate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CosineDecayLearningRate* New() const final {
    return new CosineDecayLearningRate();
  }

  CosineDecayLearningRate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CosineDecayLearningRate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CosineDecayLearningRate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CosineDecayLearningRate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CosineDecayLearningRate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "object_detection.protos.CosineDecayLearningRate";
  }
  protected:
  explicit CosineDecayLearningRate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHoldBaseRateStepsFieldNumber = 5,
    kLearningRateBaseFieldNumber = 1,
    kTotalStepsFieldNumber = 2,
    kWarmupLearningRateFieldNumber = 3,
    kWarmupStepsFieldNumber = 4,
  };
  // optional uint32 hold_base_rate_steps = 5 [default = 0];
  bool has_hold_base_rate_steps() const;
  private:
  bool _internal_has_hold_base_rate_steps() const;
  public:
  void clear_hold_base_rate_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 hold_base_rate_steps() const;
  void set_hold_base_rate_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hold_base_rate_steps() const;
  void _internal_set_hold_base_rate_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float learning_rate_base = 1 [default = 0.002];
  bool has_learning_rate_base() const;
  private:
  bool _internal_has_learning_rate_base() const;
  public:
  void clear_learning_rate_base();
  float learning_rate_base() const;
  void set_learning_rate_base(float value);
  private:
  float _internal_learning_rate_base() const;
  void _internal_set_learning_rate_base(float value);
  public:

  // optional uint32 total_steps = 2 [default = 4000000];
  bool has_total_steps() const;
  private:
  bool _internal_has_total_steps() const;
  public:
  void clear_total_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_steps() const;
  void set_total_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_total_steps() const;
  void _internal_set_total_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float warmup_learning_rate = 3 [default = 0.0002];
  bool has_warmup_learning_rate() const;
  private:
  bool _internal_has_warmup_learning_rate() const;
  public:
  void clear_warmup_learning_rate();
  float warmup_learning_rate() const;
  void set_warmup_learning_rate(float value);
  private:
  float _internal_warmup_learning_rate() const;
  void _internal_set_warmup_learning_rate(float value);
  public:

  // optional uint32 warmup_steps = 4 [default = 10000];
  bool has_warmup_steps() const;
  private:
  bool _internal_has_warmup_steps() const;
  public:
  void clear_warmup_steps();
  ::PROTOBUF_NAMESPACE_ID::uint32 warmup_steps() const;
  void set_warmup_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_warmup_steps() const;
  void _internal_set_warmup_steps(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:object_detection.protos.CosineDecayLearningRate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hold_base_rate_steps_;
  float learning_rate_base_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_steps_;
  float warmup_learning_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 warmup_steps_;
  friend struct ::TableStruct_object_5fdetection_2fprotos_2foptimizer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Optimizer

// .object_detection.protos.RMSPropOptimizer rms_prop_optimizer = 1;
inline bool Optimizer::_internal_has_rms_prop_optimizer() const {
  return optimizer_case() == kRmsPropOptimizer;
}
inline bool Optimizer::has_rms_prop_optimizer() const {
  return _internal_has_rms_prop_optimizer();
}
inline void Optimizer::set_has_rms_prop_optimizer() {
  _oneof_case_[0] = kRmsPropOptimizer;
}
inline void Optimizer::clear_rms_prop_optimizer() {
  if (_internal_has_rms_prop_optimizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete optimizer_.rms_prop_optimizer_;
    }
    clear_has_optimizer();
  }
}
inline ::object_detection::protos::RMSPropOptimizer* Optimizer::release_rms_prop_optimizer() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Optimizer.rms_prop_optimizer)
  if (_internal_has_rms_prop_optimizer()) {
    clear_has_optimizer();
      ::object_detection::protos::RMSPropOptimizer* temp = optimizer_.rms_prop_optimizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    optimizer_.rms_prop_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::RMSPropOptimizer& Optimizer::_internal_rms_prop_optimizer() const {
  return _internal_has_rms_prop_optimizer()
      ? *optimizer_.rms_prop_optimizer_
      : reinterpret_cast< ::object_detection::protos::RMSPropOptimizer&>(::object_detection::protos::_RMSPropOptimizer_default_instance_);
}
inline const ::object_detection::protos::RMSPropOptimizer& Optimizer::rms_prop_optimizer() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Optimizer.rms_prop_optimizer)
  return _internal_rms_prop_optimizer();
}
inline ::object_detection::protos::RMSPropOptimizer* Optimizer::unsafe_arena_release_rms_prop_optimizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.Optimizer.rms_prop_optimizer)
  if (_internal_has_rms_prop_optimizer()) {
    clear_has_optimizer();
    ::object_detection::protos::RMSPropOptimizer* temp = optimizer_.rms_prop_optimizer_;
    optimizer_.rms_prop_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Optimizer::unsafe_arena_set_allocated_rms_prop_optimizer(::object_detection::protos::RMSPropOptimizer* rms_prop_optimizer) {
  clear_optimizer();
  if (rms_prop_optimizer) {
    set_has_rms_prop_optimizer();
    optimizer_.rms_prop_optimizer_ = rms_prop_optimizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.Optimizer.rms_prop_optimizer)
}
inline ::object_detection::protos::RMSPropOptimizer* Optimizer::_internal_mutable_rms_prop_optimizer() {
  if (!_internal_has_rms_prop_optimizer()) {
    clear_optimizer();
    set_has_rms_prop_optimizer();
    optimizer_.rms_prop_optimizer_ = CreateMaybeMessage< ::object_detection::protos::RMSPropOptimizer >(GetArenaForAllocation());
  }
  return optimizer_.rms_prop_optimizer_;
}
inline ::object_detection::protos::RMSPropOptimizer* Optimizer::mutable_rms_prop_optimizer() {
  ::object_detection::protos::RMSPropOptimizer* _msg = _internal_mutable_rms_prop_optimizer();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Optimizer.rms_prop_optimizer)
  return _msg;
}

// .object_detection.protos.MomentumOptimizer momentum_optimizer = 2;
inline bool Optimizer::_internal_has_momentum_optimizer() const {
  return optimizer_case() == kMomentumOptimizer;
}
inline bool Optimizer::has_momentum_optimizer() const {
  return _internal_has_momentum_optimizer();
}
inline void Optimizer::set_has_momentum_optimizer() {
  _oneof_case_[0] = kMomentumOptimizer;
}
inline void Optimizer::clear_momentum_optimizer() {
  if (_internal_has_momentum_optimizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete optimizer_.momentum_optimizer_;
    }
    clear_has_optimizer();
  }
}
inline ::object_detection::protos::MomentumOptimizer* Optimizer::release_momentum_optimizer() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Optimizer.momentum_optimizer)
  if (_internal_has_momentum_optimizer()) {
    clear_has_optimizer();
      ::object_detection::protos::MomentumOptimizer* temp = optimizer_.momentum_optimizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    optimizer_.momentum_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::MomentumOptimizer& Optimizer::_internal_momentum_optimizer() const {
  return _internal_has_momentum_optimizer()
      ? *optimizer_.momentum_optimizer_
      : reinterpret_cast< ::object_detection::protos::MomentumOptimizer&>(::object_detection::protos::_MomentumOptimizer_default_instance_);
}
inline const ::object_detection::protos::MomentumOptimizer& Optimizer::momentum_optimizer() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Optimizer.momentum_optimizer)
  return _internal_momentum_optimizer();
}
inline ::object_detection::protos::MomentumOptimizer* Optimizer::unsafe_arena_release_momentum_optimizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.Optimizer.momentum_optimizer)
  if (_internal_has_momentum_optimizer()) {
    clear_has_optimizer();
    ::object_detection::protos::MomentumOptimizer* temp = optimizer_.momentum_optimizer_;
    optimizer_.momentum_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Optimizer::unsafe_arena_set_allocated_momentum_optimizer(::object_detection::protos::MomentumOptimizer* momentum_optimizer) {
  clear_optimizer();
  if (momentum_optimizer) {
    set_has_momentum_optimizer();
    optimizer_.momentum_optimizer_ = momentum_optimizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.Optimizer.momentum_optimizer)
}
inline ::object_detection::protos::MomentumOptimizer* Optimizer::_internal_mutable_momentum_optimizer() {
  if (!_internal_has_momentum_optimizer()) {
    clear_optimizer();
    set_has_momentum_optimizer();
    optimizer_.momentum_optimizer_ = CreateMaybeMessage< ::object_detection::protos::MomentumOptimizer >(GetArenaForAllocation());
  }
  return optimizer_.momentum_optimizer_;
}
inline ::object_detection::protos::MomentumOptimizer* Optimizer::mutable_momentum_optimizer() {
  ::object_detection::protos::MomentumOptimizer* _msg = _internal_mutable_momentum_optimizer();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Optimizer.momentum_optimizer)
  return _msg;
}

// .object_detection.protos.AdamOptimizer adam_optimizer = 3;
inline bool Optimizer::_internal_has_adam_optimizer() const {
  return optimizer_case() == kAdamOptimizer;
}
inline bool Optimizer::has_adam_optimizer() const {
  return _internal_has_adam_optimizer();
}
inline void Optimizer::set_has_adam_optimizer() {
  _oneof_case_[0] = kAdamOptimizer;
}
inline void Optimizer::clear_adam_optimizer() {
  if (_internal_has_adam_optimizer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete optimizer_.adam_optimizer_;
    }
    clear_has_optimizer();
  }
}
inline ::object_detection::protos::AdamOptimizer* Optimizer::release_adam_optimizer() {
  // @@protoc_insertion_point(field_release:object_detection.protos.Optimizer.adam_optimizer)
  if (_internal_has_adam_optimizer()) {
    clear_has_optimizer();
      ::object_detection::protos::AdamOptimizer* temp = optimizer_.adam_optimizer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    optimizer_.adam_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::AdamOptimizer& Optimizer::_internal_adam_optimizer() const {
  return _internal_has_adam_optimizer()
      ? *optimizer_.adam_optimizer_
      : reinterpret_cast< ::object_detection::protos::AdamOptimizer&>(::object_detection::protos::_AdamOptimizer_default_instance_);
}
inline const ::object_detection::protos::AdamOptimizer& Optimizer::adam_optimizer() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Optimizer.adam_optimizer)
  return _internal_adam_optimizer();
}
inline ::object_detection::protos::AdamOptimizer* Optimizer::unsafe_arena_release_adam_optimizer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.Optimizer.adam_optimizer)
  if (_internal_has_adam_optimizer()) {
    clear_has_optimizer();
    ::object_detection::protos::AdamOptimizer* temp = optimizer_.adam_optimizer_;
    optimizer_.adam_optimizer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Optimizer::unsafe_arena_set_allocated_adam_optimizer(::object_detection::protos::AdamOptimizer* adam_optimizer) {
  clear_optimizer();
  if (adam_optimizer) {
    set_has_adam_optimizer();
    optimizer_.adam_optimizer_ = adam_optimizer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.Optimizer.adam_optimizer)
}
inline ::object_detection::protos::AdamOptimizer* Optimizer::_internal_mutable_adam_optimizer() {
  if (!_internal_has_adam_optimizer()) {
    clear_optimizer();
    set_has_adam_optimizer();
    optimizer_.adam_optimizer_ = CreateMaybeMessage< ::object_detection::protos::AdamOptimizer >(GetArenaForAllocation());
  }
  return optimizer_.adam_optimizer_;
}
inline ::object_detection::protos::AdamOptimizer* Optimizer::mutable_adam_optimizer() {
  ::object_detection::protos::AdamOptimizer* _msg = _internal_mutable_adam_optimizer();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.Optimizer.adam_optimizer)
  return _msg;
}

// optional bool use_moving_average = 4 [default = true];
inline bool Optimizer::_internal_has_use_moving_average() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Optimizer::has_use_moving_average() const {
  return _internal_has_use_moving_average();
}
inline void Optimizer::clear_use_moving_average() {
  use_moving_average_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Optimizer::_internal_use_moving_average() const {
  return use_moving_average_;
}
inline bool Optimizer::use_moving_average() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Optimizer.use_moving_average)
  return _internal_use_moving_average();
}
inline void Optimizer::_internal_set_use_moving_average(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_moving_average_ = value;
}
inline void Optimizer::set_use_moving_average(bool value) {
  _internal_set_use_moving_average(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.Optimizer.use_moving_average)
}

// optional float moving_average_decay = 5 [default = 0.9999];
inline bool Optimizer::_internal_has_moving_average_decay() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Optimizer::has_moving_average_decay() const {
  return _internal_has_moving_average_decay();
}
inline void Optimizer::clear_moving_average_decay() {
  moving_average_decay_ = 0.9999f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Optimizer::_internal_moving_average_decay() const {
  return moving_average_decay_;
}
inline float Optimizer::moving_average_decay() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.Optimizer.moving_average_decay)
  return _internal_moving_average_decay();
}
inline void Optimizer::_internal_set_moving_average_decay(float value) {
  _has_bits_[0] |= 0x00000002u;
  moving_average_decay_ = value;
}
inline void Optimizer::set_moving_average_decay(float value) {
  _internal_set_moving_average_decay(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.Optimizer.moving_average_decay)
}

inline bool Optimizer::has_optimizer() const {
  return optimizer_case() != OPTIMIZER_NOT_SET;
}
inline void Optimizer::clear_has_optimizer() {
  _oneof_case_[0] = OPTIMIZER_NOT_SET;
}
inline Optimizer::OptimizerCase Optimizer::optimizer_case() const {
  return Optimizer::OptimizerCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RMSPropOptimizer

// optional .object_detection.protos.LearningRate learning_rate = 1;
inline bool RMSPropOptimizer::_internal_has_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || learning_rate_ != nullptr);
  return value;
}
inline bool RMSPropOptimizer::has_learning_rate() const {
  return _internal_has_learning_rate();
}
inline void RMSPropOptimizer::clear_learning_rate() {
  if (learning_rate_ != nullptr) learning_rate_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::object_detection::protos::LearningRate& RMSPropOptimizer::_internal_learning_rate() const {
  const ::object_detection::protos::LearningRate* p = learning_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::object_detection::protos::LearningRate&>(
      ::object_detection::protos::_LearningRate_default_instance_);
}
inline const ::object_detection::protos::LearningRate& RMSPropOptimizer::learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RMSPropOptimizer.learning_rate)
  return _internal_learning_rate();
}
inline void RMSPropOptimizer::unsafe_arena_set_allocated_learning_rate(
    ::object_detection::protos::LearningRate* learning_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(learning_rate_);
  }
  learning_rate_ = learning_rate;
  if (learning_rate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.RMSPropOptimizer.learning_rate)
}
inline ::object_detection::protos::LearningRate* RMSPropOptimizer::release_learning_rate() {
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::object_detection::protos::LearningRate* RMSPropOptimizer::unsafe_arena_release_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.RMSPropOptimizer.learning_rate)
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
  return temp;
}
inline ::object_detection::protos::LearningRate* RMSPropOptimizer::_internal_mutable_learning_rate() {
  _has_bits_[0] |= 0x00000001u;
  if (learning_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::object_detection::protos::LearningRate>(GetArenaForAllocation());
    learning_rate_ = p;
  }
  return learning_rate_;
}
inline ::object_detection::protos::LearningRate* RMSPropOptimizer::mutable_learning_rate() {
  ::object_detection::protos::LearningRate* _msg = _internal_mutable_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.RMSPropOptimizer.learning_rate)
  return _msg;
}
inline void RMSPropOptimizer::set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete learning_rate_;
  }
  if (learning_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::object_detection::protos::LearningRate>::GetOwningArena(learning_rate);
    if (message_arena != submessage_arena) {
      learning_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, learning_rate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  learning_rate_ = learning_rate;
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.RMSPropOptimizer.learning_rate)
}

// optional float momentum_optimizer_value = 2 [default = 0.9];
inline bool RMSPropOptimizer::_internal_has_momentum_optimizer_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RMSPropOptimizer::has_momentum_optimizer_value() const {
  return _internal_has_momentum_optimizer_value();
}
inline void RMSPropOptimizer::clear_momentum_optimizer_value() {
  momentum_optimizer_value_ = 0.9f;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RMSPropOptimizer::_internal_momentum_optimizer_value() const {
  return momentum_optimizer_value_;
}
inline float RMSPropOptimizer::momentum_optimizer_value() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RMSPropOptimizer.momentum_optimizer_value)
  return _internal_momentum_optimizer_value();
}
inline void RMSPropOptimizer::_internal_set_momentum_optimizer_value(float value) {
  _has_bits_[0] |= 0x00000004u;
  momentum_optimizer_value_ = value;
}
inline void RMSPropOptimizer::set_momentum_optimizer_value(float value) {
  _internal_set_momentum_optimizer_value(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RMSPropOptimizer.momentum_optimizer_value)
}

// optional float decay = 3 [default = 0.9];
inline bool RMSPropOptimizer::_internal_has_decay() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RMSPropOptimizer::has_decay() const {
  return _internal_has_decay();
}
inline void RMSPropOptimizer::clear_decay() {
  decay_ = 0.9f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float RMSPropOptimizer::_internal_decay() const {
  return decay_;
}
inline float RMSPropOptimizer::decay() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RMSPropOptimizer.decay)
  return _internal_decay();
}
inline void RMSPropOptimizer::_internal_set_decay(float value) {
  _has_bits_[0] |= 0x00000008u;
  decay_ = value;
}
inline void RMSPropOptimizer::set_decay(float value) {
  _internal_set_decay(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RMSPropOptimizer.decay)
}

// optional float epsilon = 4 [default = 1];
inline bool RMSPropOptimizer::_internal_has_epsilon() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RMSPropOptimizer::has_epsilon() const {
  return _internal_has_epsilon();
}
inline void RMSPropOptimizer::clear_epsilon() {
  epsilon_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RMSPropOptimizer::_internal_epsilon() const {
  return epsilon_;
}
inline float RMSPropOptimizer::epsilon() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.RMSPropOptimizer.epsilon)
  return _internal_epsilon();
}
inline void RMSPropOptimizer::_internal_set_epsilon(float value) {
  _has_bits_[0] |= 0x00000002u;
  epsilon_ = value;
}
inline void RMSPropOptimizer::set_epsilon(float value) {
  _internal_set_epsilon(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.RMSPropOptimizer.epsilon)
}

// -------------------------------------------------------------------

// MomentumOptimizer

// optional .object_detection.protos.LearningRate learning_rate = 1;
inline bool MomentumOptimizer::_internal_has_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || learning_rate_ != nullptr);
  return value;
}
inline bool MomentumOptimizer::has_learning_rate() const {
  return _internal_has_learning_rate();
}
inline void MomentumOptimizer::clear_learning_rate() {
  if (learning_rate_ != nullptr) learning_rate_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::object_detection::protos::LearningRate& MomentumOptimizer::_internal_learning_rate() const {
  const ::object_detection::protos::LearningRate* p = learning_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::object_detection::protos::LearningRate&>(
      ::object_detection::protos::_LearningRate_default_instance_);
}
inline const ::object_detection::protos::LearningRate& MomentumOptimizer::learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.MomentumOptimizer.learning_rate)
  return _internal_learning_rate();
}
inline void MomentumOptimizer::unsafe_arena_set_allocated_learning_rate(
    ::object_detection::protos::LearningRate* learning_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(learning_rate_);
  }
  learning_rate_ = learning_rate;
  if (learning_rate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.MomentumOptimizer.learning_rate)
}
inline ::object_detection::protos::LearningRate* MomentumOptimizer::release_learning_rate() {
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::object_detection::protos::LearningRate* MomentumOptimizer::unsafe_arena_release_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.MomentumOptimizer.learning_rate)
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
  return temp;
}
inline ::object_detection::protos::LearningRate* MomentumOptimizer::_internal_mutable_learning_rate() {
  _has_bits_[0] |= 0x00000001u;
  if (learning_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::object_detection::protos::LearningRate>(GetArenaForAllocation());
    learning_rate_ = p;
  }
  return learning_rate_;
}
inline ::object_detection::protos::LearningRate* MomentumOptimizer::mutable_learning_rate() {
  ::object_detection::protos::LearningRate* _msg = _internal_mutable_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.MomentumOptimizer.learning_rate)
  return _msg;
}
inline void MomentumOptimizer::set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete learning_rate_;
  }
  if (learning_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::object_detection::protos::LearningRate>::GetOwningArena(learning_rate);
    if (message_arena != submessage_arena) {
      learning_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, learning_rate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  learning_rate_ = learning_rate;
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.MomentumOptimizer.learning_rate)
}

// optional float momentum_optimizer_value = 2 [default = 0.9];
inline bool MomentumOptimizer::_internal_has_momentum_optimizer_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MomentumOptimizer::has_momentum_optimizer_value() const {
  return _internal_has_momentum_optimizer_value();
}
inline void MomentumOptimizer::clear_momentum_optimizer_value() {
  momentum_optimizer_value_ = 0.9f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float MomentumOptimizer::_internal_momentum_optimizer_value() const {
  return momentum_optimizer_value_;
}
inline float MomentumOptimizer::momentum_optimizer_value() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.MomentumOptimizer.momentum_optimizer_value)
  return _internal_momentum_optimizer_value();
}
inline void MomentumOptimizer::_internal_set_momentum_optimizer_value(float value) {
  _has_bits_[0] |= 0x00000002u;
  momentum_optimizer_value_ = value;
}
inline void MomentumOptimizer::set_momentum_optimizer_value(float value) {
  _internal_set_momentum_optimizer_value(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.MomentumOptimizer.momentum_optimizer_value)
}

// -------------------------------------------------------------------

// AdamOptimizer

// optional .object_detection.protos.LearningRate learning_rate = 1;
inline bool AdamOptimizer::_internal_has_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || learning_rate_ != nullptr);
  return value;
}
inline bool AdamOptimizer::has_learning_rate() const {
  return _internal_has_learning_rate();
}
inline void AdamOptimizer::clear_learning_rate() {
  if (learning_rate_ != nullptr) learning_rate_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::object_detection::protos::LearningRate& AdamOptimizer::_internal_learning_rate() const {
  const ::object_detection::protos::LearningRate* p = learning_rate_;
  return p != nullptr ? *p : reinterpret_cast<const ::object_detection::protos::LearningRate&>(
      ::object_detection::protos::_LearningRate_default_instance_);
}
inline const ::object_detection::protos::LearningRate& AdamOptimizer::learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.AdamOptimizer.learning_rate)
  return _internal_learning_rate();
}
inline void AdamOptimizer::unsafe_arena_set_allocated_learning_rate(
    ::object_detection::protos::LearningRate* learning_rate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(learning_rate_);
  }
  learning_rate_ = learning_rate;
  if (learning_rate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.AdamOptimizer.learning_rate)
}
inline ::object_detection::protos::LearningRate* AdamOptimizer::release_learning_rate() {
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::object_detection::protos::LearningRate* AdamOptimizer::unsafe_arena_release_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.AdamOptimizer.learning_rate)
  _has_bits_[0] &= ~0x00000001u;
  ::object_detection::protos::LearningRate* temp = learning_rate_;
  learning_rate_ = nullptr;
  return temp;
}
inline ::object_detection::protos::LearningRate* AdamOptimizer::_internal_mutable_learning_rate() {
  _has_bits_[0] |= 0x00000001u;
  if (learning_rate_ == nullptr) {
    auto* p = CreateMaybeMessage<::object_detection::protos::LearningRate>(GetArenaForAllocation());
    learning_rate_ = p;
  }
  return learning_rate_;
}
inline ::object_detection::protos::LearningRate* AdamOptimizer::mutable_learning_rate() {
  ::object_detection::protos::LearningRate* _msg = _internal_mutable_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.AdamOptimizer.learning_rate)
  return _msg;
}
inline void AdamOptimizer::set_allocated_learning_rate(::object_detection::protos::LearningRate* learning_rate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete learning_rate_;
  }
  if (learning_rate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::object_detection::protos::LearningRate>::GetOwningArena(learning_rate);
    if (message_arena != submessage_arena) {
      learning_rate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, learning_rate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  learning_rate_ = learning_rate;
  // @@protoc_insertion_point(field_set_allocated:object_detection.protos.AdamOptimizer.learning_rate)
}

// -------------------------------------------------------------------

// LearningRate

// .object_detection.protos.ConstantLearningRate constant_learning_rate = 1;
inline bool LearningRate::_internal_has_constant_learning_rate() const {
  return learning_rate_case() == kConstantLearningRate;
}
inline bool LearningRate::has_constant_learning_rate() const {
  return _internal_has_constant_learning_rate();
}
inline void LearningRate::set_has_constant_learning_rate() {
  _oneof_case_[0] = kConstantLearningRate;
}
inline void LearningRate::clear_constant_learning_rate() {
  if (_internal_has_constant_learning_rate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete learning_rate_.constant_learning_rate_;
    }
    clear_has_learning_rate();
  }
}
inline ::object_detection::protos::ConstantLearningRate* LearningRate::release_constant_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.LearningRate.constant_learning_rate)
  if (_internal_has_constant_learning_rate()) {
    clear_has_learning_rate();
      ::object_detection::protos::ConstantLearningRate* temp = learning_rate_.constant_learning_rate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    learning_rate_.constant_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::ConstantLearningRate& LearningRate::_internal_constant_learning_rate() const {
  return _internal_has_constant_learning_rate()
      ? *learning_rate_.constant_learning_rate_
      : reinterpret_cast< ::object_detection::protos::ConstantLearningRate&>(::object_detection::protos::_ConstantLearningRate_default_instance_);
}
inline const ::object_detection::protos::ConstantLearningRate& LearningRate::constant_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.LearningRate.constant_learning_rate)
  return _internal_constant_learning_rate();
}
inline ::object_detection::protos::ConstantLearningRate* LearningRate::unsafe_arena_release_constant_learning_rate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.LearningRate.constant_learning_rate)
  if (_internal_has_constant_learning_rate()) {
    clear_has_learning_rate();
    ::object_detection::protos::ConstantLearningRate* temp = learning_rate_.constant_learning_rate_;
    learning_rate_.constant_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LearningRate::unsafe_arena_set_allocated_constant_learning_rate(::object_detection::protos::ConstantLearningRate* constant_learning_rate) {
  clear_learning_rate();
  if (constant_learning_rate) {
    set_has_constant_learning_rate();
    learning_rate_.constant_learning_rate_ = constant_learning_rate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.LearningRate.constant_learning_rate)
}
inline ::object_detection::protos::ConstantLearningRate* LearningRate::_internal_mutable_constant_learning_rate() {
  if (!_internal_has_constant_learning_rate()) {
    clear_learning_rate();
    set_has_constant_learning_rate();
    learning_rate_.constant_learning_rate_ = CreateMaybeMessage< ::object_detection::protos::ConstantLearningRate >(GetArenaForAllocation());
  }
  return learning_rate_.constant_learning_rate_;
}
inline ::object_detection::protos::ConstantLearningRate* LearningRate::mutable_constant_learning_rate() {
  ::object_detection::protos::ConstantLearningRate* _msg = _internal_mutable_constant_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.LearningRate.constant_learning_rate)
  return _msg;
}

// .object_detection.protos.ExponentialDecayLearningRate exponential_decay_learning_rate = 2;
inline bool LearningRate::_internal_has_exponential_decay_learning_rate() const {
  return learning_rate_case() == kExponentialDecayLearningRate;
}
inline bool LearningRate::has_exponential_decay_learning_rate() const {
  return _internal_has_exponential_decay_learning_rate();
}
inline void LearningRate::set_has_exponential_decay_learning_rate() {
  _oneof_case_[0] = kExponentialDecayLearningRate;
}
inline void LearningRate::clear_exponential_decay_learning_rate() {
  if (_internal_has_exponential_decay_learning_rate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete learning_rate_.exponential_decay_learning_rate_;
    }
    clear_has_learning_rate();
  }
}
inline ::object_detection::protos::ExponentialDecayLearningRate* LearningRate::release_exponential_decay_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.LearningRate.exponential_decay_learning_rate)
  if (_internal_has_exponential_decay_learning_rate()) {
    clear_has_learning_rate();
      ::object_detection::protos::ExponentialDecayLearningRate* temp = learning_rate_.exponential_decay_learning_rate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    learning_rate_.exponential_decay_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::ExponentialDecayLearningRate& LearningRate::_internal_exponential_decay_learning_rate() const {
  return _internal_has_exponential_decay_learning_rate()
      ? *learning_rate_.exponential_decay_learning_rate_
      : reinterpret_cast< ::object_detection::protos::ExponentialDecayLearningRate&>(::object_detection::protos::_ExponentialDecayLearningRate_default_instance_);
}
inline const ::object_detection::protos::ExponentialDecayLearningRate& LearningRate::exponential_decay_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.LearningRate.exponential_decay_learning_rate)
  return _internal_exponential_decay_learning_rate();
}
inline ::object_detection::protos::ExponentialDecayLearningRate* LearningRate::unsafe_arena_release_exponential_decay_learning_rate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.LearningRate.exponential_decay_learning_rate)
  if (_internal_has_exponential_decay_learning_rate()) {
    clear_has_learning_rate();
    ::object_detection::protos::ExponentialDecayLearningRate* temp = learning_rate_.exponential_decay_learning_rate_;
    learning_rate_.exponential_decay_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LearningRate::unsafe_arena_set_allocated_exponential_decay_learning_rate(::object_detection::protos::ExponentialDecayLearningRate* exponential_decay_learning_rate) {
  clear_learning_rate();
  if (exponential_decay_learning_rate) {
    set_has_exponential_decay_learning_rate();
    learning_rate_.exponential_decay_learning_rate_ = exponential_decay_learning_rate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.LearningRate.exponential_decay_learning_rate)
}
inline ::object_detection::protos::ExponentialDecayLearningRate* LearningRate::_internal_mutable_exponential_decay_learning_rate() {
  if (!_internal_has_exponential_decay_learning_rate()) {
    clear_learning_rate();
    set_has_exponential_decay_learning_rate();
    learning_rate_.exponential_decay_learning_rate_ = CreateMaybeMessage< ::object_detection::protos::ExponentialDecayLearningRate >(GetArenaForAllocation());
  }
  return learning_rate_.exponential_decay_learning_rate_;
}
inline ::object_detection::protos::ExponentialDecayLearningRate* LearningRate::mutable_exponential_decay_learning_rate() {
  ::object_detection::protos::ExponentialDecayLearningRate* _msg = _internal_mutable_exponential_decay_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.LearningRate.exponential_decay_learning_rate)
  return _msg;
}

// .object_detection.protos.ManualStepLearningRate manual_step_learning_rate = 3;
inline bool LearningRate::_internal_has_manual_step_learning_rate() const {
  return learning_rate_case() == kManualStepLearningRate;
}
inline bool LearningRate::has_manual_step_learning_rate() const {
  return _internal_has_manual_step_learning_rate();
}
inline void LearningRate::set_has_manual_step_learning_rate() {
  _oneof_case_[0] = kManualStepLearningRate;
}
inline void LearningRate::clear_manual_step_learning_rate() {
  if (_internal_has_manual_step_learning_rate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete learning_rate_.manual_step_learning_rate_;
    }
    clear_has_learning_rate();
  }
}
inline ::object_detection::protos::ManualStepLearningRate* LearningRate::release_manual_step_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.LearningRate.manual_step_learning_rate)
  if (_internal_has_manual_step_learning_rate()) {
    clear_has_learning_rate();
      ::object_detection::protos::ManualStepLearningRate* temp = learning_rate_.manual_step_learning_rate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    learning_rate_.manual_step_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::ManualStepLearningRate& LearningRate::_internal_manual_step_learning_rate() const {
  return _internal_has_manual_step_learning_rate()
      ? *learning_rate_.manual_step_learning_rate_
      : reinterpret_cast< ::object_detection::protos::ManualStepLearningRate&>(::object_detection::protos::_ManualStepLearningRate_default_instance_);
}
inline const ::object_detection::protos::ManualStepLearningRate& LearningRate::manual_step_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.LearningRate.manual_step_learning_rate)
  return _internal_manual_step_learning_rate();
}
inline ::object_detection::protos::ManualStepLearningRate* LearningRate::unsafe_arena_release_manual_step_learning_rate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.LearningRate.manual_step_learning_rate)
  if (_internal_has_manual_step_learning_rate()) {
    clear_has_learning_rate();
    ::object_detection::protos::ManualStepLearningRate* temp = learning_rate_.manual_step_learning_rate_;
    learning_rate_.manual_step_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LearningRate::unsafe_arena_set_allocated_manual_step_learning_rate(::object_detection::protos::ManualStepLearningRate* manual_step_learning_rate) {
  clear_learning_rate();
  if (manual_step_learning_rate) {
    set_has_manual_step_learning_rate();
    learning_rate_.manual_step_learning_rate_ = manual_step_learning_rate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.LearningRate.manual_step_learning_rate)
}
inline ::object_detection::protos::ManualStepLearningRate* LearningRate::_internal_mutable_manual_step_learning_rate() {
  if (!_internal_has_manual_step_learning_rate()) {
    clear_learning_rate();
    set_has_manual_step_learning_rate();
    learning_rate_.manual_step_learning_rate_ = CreateMaybeMessage< ::object_detection::protos::ManualStepLearningRate >(GetArenaForAllocation());
  }
  return learning_rate_.manual_step_learning_rate_;
}
inline ::object_detection::protos::ManualStepLearningRate* LearningRate::mutable_manual_step_learning_rate() {
  ::object_detection::protos::ManualStepLearningRate* _msg = _internal_mutable_manual_step_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.LearningRate.manual_step_learning_rate)
  return _msg;
}

// .object_detection.protos.CosineDecayLearningRate cosine_decay_learning_rate = 4;
inline bool LearningRate::_internal_has_cosine_decay_learning_rate() const {
  return learning_rate_case() == kCosineDecayLearningRate;
}
inline bool LearningRate::has_cosine_decay_learning_rate() const {
  return _internal_has_cosine_decay_learning_rate();
}
inline void LearningRate::set_has_cosine_decay_learning_rate() {
  _oneof_case_[0] = kCosineDecayLearningRate;
}
inline void LearningRate::clear_cosine_decay_learning_rate() {
  if (_internal_has_cosine_decay_learning_rate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete learning_rate_.cosine_decay_learning_rate_;
    }
    clear_has_learning_rate();
  }
}
inline ::object_detection::protos::CosineDecayLearningRate* LearningRate::release_cosine_decay_learning_rate() {
  // @@protoc_insertion_point(field_release:object_detection.protos.LearningRate.cosine_decay_learning_rate)
  if (_internal_has_cosine_decay_learning_rate()) {
    clear_has_learning_rate();
      ::object_detection::protos::CosineDecayLearningRate* temp = learning_rate_.cosine_decay_learning_rate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    learning_rate_.cosine_decay_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::object_detection::protos::CosineDecayLearningRate& LearningRate::_internal_cosine_decay_learning_rate() const {
  return _internal_has_cosine_decay_learning_rate()
      ? *learning_rate_.cosine_decay_learning_rate_
      : reinterpret_cast< ::object_detection::protos::CosineDecayLearningRate&>(::object_detection::protos::_CosineDecayLearningRate_default_instance_);
}
inline const ::object_detection::protos::CosineDecayLearningRate& LearningRate::cosine_decay_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.LearningRate.cosine_decay_learning_rate)
  return _internal_cosine_decay_learning_rate();
}
inline ::object_detection::protos::CosineDecayLearningRate* LearningRate::unsafe_arena_release_cosine_decay_learning_rate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:object_detection.protos.LearningRate.cosine_decay_learning_rate)
  if (_internal_has_cosine_decay_learning_rate()) {
    clear_has_learning_rate();
    ::object_detection::protos::CosineDecayLearningRate* temp = learning_rate_.cosine_decay_learning_rate_;
    learning_rate_.cosine_decay_learning_rate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LearningRate::unsafe_arena_set_allocated_cosine_decay_learning_rate(::object_detection::protos::CosineDecayLearningRate* cosine_decay_learning_rate) {
  clear_learning_rate();
  if (cosine_decay_learning_rate) {
    set_has_cosine_decay_learning_rate();
    learning_rate_.cosine_decay_learning_rate_ = cosine_decay_learning_rate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:object_detection.protos.LearningRate.cosine_decay_learning_rate)
}
inline ::object_detection::protos::CosineDecayLearningRate* LearningRate::_internal_mutable_cosine_decay_learning_rate() {
  if (!_internal_has_cosine_decay_learning_rate()) {
    clear_learning_rate();
    set_has_cosine_decay_learning_rate();
    learning_rate_.cosine_decay_learning_rate_ = CreateMaybeMessage< ::object_detection::protos::CosineDecayLearningRate >(GetArenaForAllocation());
  }
  return learning_rate_.cosine_decay_learning_rate_;
}
inline ::object_detection::protos::CosineDecayLearningRate* LearningRate::mutable_cosine_decay_learning_rate() {
  ::object_detection::protos::CosineDecayLearningRate* _msg = _internal_mutable_cosine_decay_learning_rate();
  // @@protoc_insertion_point(field_mutable:object_detection.protos.LearningRate.cosine_decay_learning_rate)
  return _msg;
}

inline bool LearningRate::has_learning_rate() const {
  return learning_rate_case() != LEARNING_RATE_NOT_SET;
}
inline void LearningRate::clear_has_learning_rate() {
  _oneof_case_[0] = LEARNING_RATE_NOT_SET;
}
inline LearningRate::LearningRateCase LearningRate::learning_rate_case() const {
  return LearningRate::LearningRateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantLearningRate

// optional float learning_rate = 1 [default = 0.002];
inline bool ConstantLearningRate::_internal_has_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConstantLearningRate::has_learning_rate() const {
  return _internal_has_learning_rate();
}
inline void ConstantLearningRate::clear_learning_rate() {
  learning_rate_ = 0.002f;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ConstantLearningRate::_internal_learning_rate() const {
  return learning_rate_;
}
inline float ConstantLearningRate::learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ConstantLearningRate.learning_rate)
  return _internal_learning_rate();
}
inline void ConstantLearningRate::_internal_set_learning_rate(float value) {
  _has_bits_[0] |= 0x00000001u;
  learning_rate_ = value;
}
inline void ConstantLearningRate::set_learning_rate(float value) {
  _internal_set_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ConstantLearningRate.learning_rate)
}

// -------------------------------------------------------------------

// ExponentialDecayLearningRate

// optional float initial_learning_rate = 1 [default = 0.002];
inline bool ExponentialDecayLearningRate::_internal_has_initial_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_initial_learning_rate() const {
  return _internal_has_initial_learning_rate();
}
inline void ExponentialDecayLearningRate::clear_initial_learning_rate() {
  initial_learning_rate_ = 0.002f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float ExponentialDecayLearningRate::_internal_initial_learning_rate() const {
  return initial_learning_rate_;
}
inline float ExponentialDecayLearningRate::initial_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.initial_learning_rate)
  return _internal_initial_learning_rate();
}
inline void ExponentialDecayLearningRate::_internal_set_initial_learning_rate(float value) {
  _has_bits_[0] |= 0x00000008u;
  initial_learning_rate_ = value;
}
inline void ExponentialDecayLearningRate::set_initial_learning_rate(float value) {
  _internal_set_initial_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.initial_learning_rate)
}

// optional uint32 decay_steps = 2 [default = 4000000];
inline bool ExponentialDecayLearningRate::_internal_has_decay_steps() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_decay_steps() const {
  return _internal_has_decay_steps();
}
inline void ExponentialDecayLearningRate::clear_decay_steps() {
  decay_steps_ = 4000000u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExponentialDecayLearningRate::_internal_decay_steps() const {
  return decay_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExponentialDecayLearningRate::decay_steps() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.decay_steps)
  return _internal_decay_steps();
}
inline void ExponentialDecayLearningRate::_internal_set_decay_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  decay_steps_ = value;
}
inline void ExponentialDecayLearningRate::set_decay_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_decay_steps(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.decay_steps)
}

// optional float decay_factor = 3 [default = 0.95];
inline bool ExponentialDecayLearningRate::_internal_has_decay_factor() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_decay_factor() const {
  return _internal_has_decay_factor();
}
inline void ExponentialDecayLearningRate::clear_decay_factor() {
  decay_factor_ = 0.95f;
  _has_bits_[0] &= ~0x00000020u;
}
inline float ExponentialDecayLearningRate::_internal_decay_factor() const {
  return decay_factor_;
}
inline float ExponentialDecayLearningRate::decay_factor() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.decay_factor)
  return _internal_decay_factor();
}
inline void ExponentialDecayLearningRate::_internal_set_decay_factor(float value) {
  _has_bits_[0] |= 0x00000020u;
  decay_factor_ = value;
}
inline void ExponentialDecayLearningRate::set_decay_factor(float value) {
  _internal_set_decay_factor(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.decay_factor)
}

// optional bool staircase = 4 [default = true];
inline bool ExponentialDecayLearningRate::_internal_has_staircase() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_staircase() const {
  return _internal_has_staircase();
}
inline void ExponentialDecayLearningRate::clear_staircase() {
  staircase_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ExponentialDecayLearningRate::_internal_staircase() const {
  return staircase_;
}
inline bool ExponentialDecayLearningRate::staircase() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.staircase)
  return _internal_staircase();
}
inline void ExponentialDecayLearningRate::_internal_set_staircase(bool value) {
  _has_bits_[0] |= 0x00000040u;
  staircase_ = value;
}
inline void ExponentialDecayLearningRate::set_staircase(bool value) {
  _internal_set_staircase(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.staircase)
}

// optional float burnin_learning_rate = 5 [default = 0];
inline bool ExponentialDecayLearningRate::_internal_has_burnin_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_burnin_learning_rate() const {
  return _internal_has_burnin_learning_rate();
}
inline void ExponentialDecayLearningRate::clear_burnin_learning_rate() {
  burnin_learning_rate_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float ExponentialDecayLearningRate::_internal_burnin_learning_rate() const {
  return burnin_learning_rate_;
}
inline float ExponentialDecayLearningRate::burnin_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.burnin_learning_rate)
  return _internal_burnin_learning_rate();
}
inline void ExponentialDecayLearningRate::_internal_set_burnin_learning_rate(float value) {
  _has_bits_[0] |= 0x00000001u;
  burnin_learning_rate_ = value;
}
inline void ExponentialDecayLearningRate::set_burnin_learning_rate(float value) {
  _internal_set_burnin_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.burnin_learning_rate)
}

// optional uint32 burnin_steps = 6 [default = 0];
inline bool ExponentialDecayLearningRate::_internal_has_burnin_steps() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_burnin_steps() const {
  return _internal_has_burnin_steps();
}
inline void ExponentialDecayLearningRate::clear_burnin_steps() {
  burnin_steps_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExponentialDecayLearningRate::_internal_burnin_steps() const {
  return burnin_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExponentialDecayLearningRate::burnin_steps() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.burnin_steps)
  return _internal_burnin_steps();
}
inline void ExponentialDecayLearningRate::_internal_set_burnin_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  burnin_steps_ = value;
}
inline void ExponentialDecayLearningRate::set_burnin_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_burnin_steps(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.burnin_steps)
}

// optional float min_learning_rate = 7 [default = 0];
inline bool ExponentialDecayLearningRate::_internal_has_min_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExponentialDecayLearningRate::has_min_learning_rate() const {
  return _internal_has_min_learning_rate();
}
inline void ExponentialDecayLearningRate::clear_min_learning_rate() {
  min_learning_rate_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float ExponentialDecayLearningRate::_internal_min_learning_rate() const {
  return min_learning_rate_;
}
inline float ExponentialDecayLearningRate::min_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ExponentialDecayLearningRate.min_learning_rate)
  return _internal_min_learning_rate();
}
inline void ExponentialDecayLearningRate::_internal_set_min_learning_rate(float value) {
  _has_bits_[0] |= 0x00000004u;
  min_learning_rate_ = value;
}
inline void ExponentialDecayLearningRate::set_min_learning_rate(float value) {
  _internal_set_min_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ExponentialDecayLearningRate.min_learning_rate)
}

// -------------------------------------------------------------------

// ManualStepLearningRate_LearningRateSchedule

// optional uint32 step = 1;
inline bool ManualStepLearningRate_LearningRateSchedule::_internal_has_step() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ManualStepLearningRate_LearningRateSchedule::has_step() const {
  return _internal_has_step();
}
inline void ManualStepLearningRate_LearningRateSchedule::clear_step() {
  step_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ManualStepLearningRate_LearningRateSchedule::_internal_step() const {
  return step_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ManualStepLearningRate_LearningRateSchedule::step() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ManualStepLearningRate.LearningRateSchedule.step)
  return _internal_step();
}
inline void ManualStepLearningRate_LearningRateSchedule::_internal_set_step(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  step_ = value;
}
inline void ManualStepLearningRate_LearningRateSchedule::set_step(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ManualStepLearningRate.LearningRateSchedule.step)
}

// optional float learning_rate = 2 [default = 0.002];
inline bool ManualStepLearningRate_LearningRateSchedule::_internal_has_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ManualStepLearningRate_LearningRateSchedule::has_learning_rate() const {
  return _internal_has_learning_rate();
}
inline void ManualStepLearningRate_LearningRateSchedule::clear_learning_rate() {
  learning_rate_ = 0.002f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ManualStepLearningRate_LearningRateSchedule::_internal_learning_rate() const {
  return learning_rate_;
}
inline float ManualStepLearningRate_LearningRateSchedule::learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ManualStepLearningRate.LearningRateSchedule.learning_rate)
  return _internal_learning_rate();
}
inline void ManualStepLearningRate_LearningRateSchedule::_internal_set_learning_rate(float value) {
  _has_bits_[0] |= 0x00000002u;
  learning_rate_ = value;
}
inline void ManualStepLearningRate_LearningRateSchedule::set_learning_rate(float value) {
  _internal_set_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ManualStepLearningRate.LearningRateSchedule.learning_rate)
}

// -------------------------------------------------------------------

// ManualStepLearningRate

// optional float initial_learning_rate = 1 [default = 0.002];
inline bool ManualStepLearningRate::_internal_has_initial_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ManualStepLearningRate::has_initial_learning_rate() const {
  return _internal_has_initial_learning_rate();
}
inline void ManualStepLearningRate::clear_initial_learning_rate() {
  initial_learning_rate_ = 0.002f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float ManualStepLearningRate::_internal_initial_learning_rate() const {
  return initial_learning_rate_;
}
inline float ManualStepLearningRate::initial_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ManualStepLearningRate.initial_learning_rate)
  return _internal_initial_learning_rate();
}
inline void ManualStepLearningRate::_internal_set_initial_learning_rate(float value) {
  _has_bits_[0] |= 0x00000002u;
  initial_learning_rate_ = value;
}
inline void ManualStepLearningRate::set_initial_learning_rate(float value) {
  _internal_set_initial_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ManualStepLearningRate.initial_learning_rate)
}

// repeated .object_detection.protos.ManualStepLearningRate.LearningRateSchedule schedule = 2;
inline int ManualStepLearningRate::_internal_schedule_size() const {
  return schedule_.size();
}
inline int ManualStepLearningRate::schedule_size() const {
  return _internal_schedule_size();
}
inline void ManualStepLearningRate::clear_schedule() {
  schedule_.Clear();
}
inline ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* ManualStepLearningRate::mutable_schedule(int index) {
  // @@protoc_insertion_point(field_mutable:object_detection.protos.ManualStepLearningRate.schedule)
  return schedule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule >*
ManualStepLearningRate::mutable_schedule() {
  // @@protoc_insertion_point(field_mutable_list:object_detection.protos.ManualStepLearningRate.schedule)
  return &schedule_;
}
inline const ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule& ManualStepLearningRate::_internal_schedule(int index) const {
  return schedule_.Get(index);
}
inline const ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule& ManualStepLearningRate::schedule(int index) const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ManualStepLearningRate.schedule)
  return _internal_schedule(index);
}
inline ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* ManualStepLearningRate::_internal_add_schedule() {
  return schedule_.Add();
}
inline ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* ManualStepLearningRate::add_schedule() {
  ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule* _add = _internal_add_schedule();
  // @@protoc_insertion_point(field_add:object_detection.protos.ManualStepLearningRate.schedule)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::object_detection::protos::ManualStepLearningRate_LearningRateSchedule >&
ManualStepLearningRate::schedule() const {
  // @@protoc_insertion_point(field_list:object_detection.protos.ManualStepLearningRate.schedule)
  return schedule_;
}

// optional bool warmup = 3 [default = false];
inline bool ManualStepLearningRate::_internal_has_warmup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ManualStepLearningRate::has_warmup() const {
  return _internal_has_warmup();
}
inline void ManualStepLearningRate::clear_warmup() {
  warmup_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ManualStepLearningRate::_internal_warmup() const {
  return warmup_;
}
inline bool ManualStepLearningRate::warmup() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.ManualStepLearningRate.warmup)
  return _internal_warmup();
}
inline void ManualStepLearningRate::_internal_set_warmup(bool value) {
  _has_bits_[0] |= 0x00000001u;
  warmup_ = value;
}
inline void ManualStepLearningRate::set_warmup(bool value) {
  _internal_set_warmup(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.ManualStepLearningRate.warmup)
}

// -------------------------------------------------------------------

// CosineDecayLearningRate

// optional float learning_rate_base = 1 [default = 0.002];
inline bool CosineDecayLearningRate::_internal_has_learning_rate_base() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CosineDecayLearningRate::has_learning_rate_base() const {
  return _internal_has_learning_rate_base();
}
inline void CosineDecayLearningRate::clear_learning_rate_base() {
  learning_rate_base_ = 0.002f;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CosineDecayLearningRate::_internal_learning_rate_base() const {
  return learning_rate_base_;
}
inline float CosineDecayLearningRate::learning_rate_base() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.CosineDecayLearningRate.learning_rate_base)
  return _internal_learning_rate_base();
}
inline void CosineDecayLearningRate::_internal_set_learning_rate_base(float value) {
  _has_bits_[0] |= 0x00000002u;
  learning_rate_base_ = value;
}
inline void CosineDecayLearningRate::set_learning_rate_base(float value) {
  _internal_set_learning_rate_base(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.CosineDecayLearningRate.learning_rate_base)
}

// optional uint32 total_steps = 2 [default = 4000000];
inline bool CosineDecayLearningRate::_internal_has_total_steps() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CosineDecayLearningRate::has_total_steps() const {
  return _internal_has_total_steps();
}
inline void CosineDecayLearningRate::clear_total_steps() {
  total_steps_ = 4000000u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::_internal_total_steps() const {
  return total_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::total_steps() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.CosineDecayLearningRate.total_steps)
  return _internal_total_steps();
}
inline void CosineDecayLearningRate::_internal_set_total_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  total_steps_ = value;
}
inline void CosineDecayLearningRate::set_total_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_total_steps(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.CosineDecayLearningRate.total_steps)
}

// optional float warmup_learning_rate = 3 [default = 0.0002];
inline bool CosineDecayLearningRate::_internal_has_warmup_learning_rate() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CosineDecayLearningRate::has_warmup_learning_rate() const {
  return _internal_has_warmup_learning_rate();
}
inline void CosineDecayLearningRate::clear_warmup_learning_rate() {
  warmup_learning_rate_ = 0.0002f;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CosineDecayLearningRate::_internal_warmup_learning_rate() const {
  return warmup_learning_rate_;
}
inline float CosineDecayLearningRate::warmup_learning_rate() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.CosineDecayLearningRate.warmup_learning_rate)
  return _internal_warmup_learning_rate();
}
inline void CosineDecayLearningRate::_internal_set_warmup_learning_rate(float value) {
  _has_bits_[0] |= 0x00000008u;
  warmup_learning_rate_ = value;
}
inline void CosineDecayLearningRate::set_warmup_learning_rate(float value) {
  _internal_set_warmup_learning_rate(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.CosineDecayLearningRate.warmup_learning_rate)
}

// optional uint32 warmup_steps = 4 [default = 10000];
inline bool CosineDecayLearningRate::_internal_has_warmup_steps() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CosineDecayLearningRate::has_warmup_steps() const {
  return _internal_has_warmup_steps();
}
inline void CosineDecayLearningRate::clear_warmup_steps() {
  warmup_steps_ = 10000u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::_internal_warmup_steps() const {
  return warmup_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::warmup_steps() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.CosineDecayLearningRate.warmup_steps)
  return _internal_warmup_steps();
}
inline void CosineDecayLearningRate::_internal_set_warmup_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  warmup_steps_ = value;
}
inline void CosineDecayLearningRate::set_warmup_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_warmup_steps(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.CosineDecayLearningRate.warmup_steps)
}

// optional uint32 hold_base_rate_steps = 5 [default = 0];
inline bool CosineDecayLearningRate::_internal_has_hold_base_rate_steps() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CosineDecayLearningRate::has_hold_base_rate_steps() const {
  return _internal_has_hold_base_rate_steps();
}
inline void CosineDecayLearningRate::clear_hold_base_rate_steps() {
  hold_base_rate_steps_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::_internal_hold_base_rate_steps() const {
  return hold_base_rate_steps_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CosineDecayLearningRate::hold_base_rate_steps() const {
  // @@protoc_insertion_point(field_get:object_detection.protos.CosineDecayLearningRate.hold_base_rate_steps)
  return _internal_hold_base_rate_steps();
}
inline void CosineDecayLearningRate::_internal_set_hold_base_rate_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  hold_base_rate_steps_ = value;
}
inline void CosineDecayLearningRate::set_hold_base_rate_steps(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hold_base_rate_steps(value);
  // @@protoc_insertion_point(field_set:object_detection.protos.CosineDecayLearningRate.hold_base_rate_steps)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace object_detection

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_object_5fdetection_2fprotos_2foptimizer_2eproto
